TEÓRICO 
BUSES
Nos referimos a un conjunto de líneas o cables que se usan para transmitir datos, señales o energía entre diferentes componentes de un sistema.
Una de las clasificaciones de los buses es según el uso del mismo estos son: Bus de datos, bus de direcciones, bus de control.
Clasificaciones son por su forma de transmisión.
Simplex: Envía información, Half Duplex: Envía y transmite por el mismo medio la información y Full Duplex: Envía y transmite información de manera simultánea.
Serial: Usa un solo conductor por el cual se transmiten los datos uno a uno y Paralelo: Los datos se transmiten todos a la vez.
Clasificaciones son por su reloj.
Síncronos: dependen de una señal de reloj para transmitir información, pueden ser de flanco ascendente o de flanco descendente y Asíncronos: envían la información sin requerir un reloj de control.

ALU
Las memorias se encuentran construidas por diferentes tecnologías, algunas usan tipos de Flip Flops para almacenar la información, otras usan transistores MOSFET.
RAM: Random Access Memory Se usa para almacenar información temporal, es
Una memoria volátil, esta memoria requiere una alta velocidad debido a que se está leyendo y escribiendo información constantemente. Es una memoria no secuencial.
ROM: Read Only Memory. Esta memoria se utiliza para almacenar datos que no cambian o que cambian muy poco, es más lenta debido a que principalmente se usa
para lectura. Es una memoria secuencial
Aplicaciones de la ROM: Transferencia de datos y portabilidad
microcontrolador embebido,  Memoria de arranque, Tablas de datos (LUT), Convertidor de datos (binario a BCD), Generador de funciones.

DATALOGGER
Un registrador de datos es un dispositivo electrónico que registra datos en el tiempo o en relación con la ubicación por medio de instrumentos y sensores propios o conectados externamente. Casi todos están basados en microcontroladores. Por lo general son pequeños, con pilas, portátiles, y equipados con un microprocesador, memoria interna para almacenamiento de datos y sensores

ATMEGA328P
Microcontrolador de 8 bits de la familia AVR de Microchip, ampliamente utilizado en proyectos de electrónica y sistemas embebidos debido a su bajo costo y facilidad de uso. 
Dispone de una memoria EEPROM interna para almacenamiento persistente, puertos digitales y analógicos, y módulos de comunicación como UART, SPI e I2C, que lo hacen ideal para aplicaciones de control y automatización.

ASSEMBLER: 

COMUNICACION SERIAL (USART-UART)
La comunicación serial USART-UART (Universal Asyn- chronous Receiver-Transmitter) permite la transmisión de datos bit a bit entre dispositivos mediante una l´ınea de recepción (RX), una l´ınea de transmisión (TX) y una conexión a tierra com´un (GND). Opcionalmente, se puede utilizar una línea de reloj (CLK) para sincronización en comunicaciones síncronas. Este protocolo es asıncrono por defecto, lo que elimina la necesidad de una línea de reloj externa, y es ampliamente utilizado en sistemas embebidos debido a su simplicidad y eficiencia. 
La UART se inicializa configurando el baud rate mediante los registros UBRRH y UBRRL, habilitando la transmisión y recepción con los bits TXEN0 y RXEN0, y definiendo el formato de datos (generalmente 8 bits por trama). Para enviar datos, se utilizan funciones como UART_sendChar, que envía un carácter tras verificar la disponibilidad del registro UDR0, o UART_sendString, que transmite cadenas de texto caracter por caracter. De forma similar, la función UART_receiveChar permite recibir datos al leer el registro UDR0 una vez que los datos están disponibles.

INICIALIZACIÓN UART:
Se configura el registro de baud rate (UBRRH y UBRRL) para definir la velocidad de
transmisión. Se habilita la recepción y transmisión (RXEN0 y TXEN0). Se establece el formato de datos (8 bits).Enviar char (UART_sendChar): Espera a que el registro esté listo y luego envía un carácter a través de UDR0. Recibir char (UART_receiveChar): Espera hasta que haya un dato recibido  y lo devuelve desde UDR0. Enviar string (UART_sendString): Envía una cadena de caracteres, enviando cada carácter de uno en uno con UART_sendChar.

PROTOCOLO (I2C)
El protocolo I2C (Inter-Integrated Circuit) es un estándar de comunicación serial s´ıncrona que utiliza dos l´ıneas, SDA (Serial Data Line) para el transporte de datos y SCL (Serial Clock Line) para la sincronización, permitiendo conectar hasta 112 dispositivos en un mismo bus. Un dispositivo maestro controla el reloj y gestiona la comunicación con los esclavos, identificados mediante direcciones únicas de 7 o 10 bits. La comunicación inicia cuando el maestro genera una condición de inicio (SDA pasa de 1 a 0 mientras SCL está en 1), seguida por el envío de la dirección del esclavo y un bit de lectura o escritura. El esclavo responde con un bit de reconocimiento (ACK) y comienza la transferencia de datos en paquetes de 8 bits, cada uno confirmado con un ACK. Al finalizar, el maestro genera una condición de parada (SDA pasa de 0 a 1 mientras SCL está en 1), liberando el bus. Este protocolo es ideal para sistemas embebidos gracias a su simplicidad, bajo consumo de pines y capacidad de soportar múltiples dispositivos, aunque puede requerir resistencias pull-up y es m´as lento que otros protocolos como SPI.
Característica: I2C,  Modo de Comunicación: Serial síncrono, el modelo de Comunicación: Maestro-Múltiples Esclavos (bus compartido) las  líneas de Comunicación: 2 líneas (SDA y SCL), la velocidad Máxima: Hasta 5 MHz (modo ultra rápido), el control de Esclavo: Dirección de dispositivo, el número de dispositivo, pueden ser múltiples esclavos en el mismo bus, el protocolo es más complejo (requiere direccionamiento y ACK), el consumo de pines es menor (2 pines compartidos) y en idoneidad las aplicaciones son de baja velocidad y múltiples dispositivos en un bus.


PROTOCOLO (SPI)
El protocolo Serial Peripheral Interface (SPI) es una interfaz serial sıncrona diseñada para la comunicación a corta distancia en un modelo maestro-esclavo. Este protocolo permite la conexión de varios dispositivos secundarios (esclavos) a un maestro, soportando velocidades de
transferencia de datos de hasta 50 MHz, lo que lo hace significativamente más rápido que otros protocolos como I2C. Una de sus características distintivas es su capacidad de comunicación full duplex, que permite transmitir y recibir datos simultáneamente. A diferencia de I2C, SPI no sigue un
estándar estricto, lo que lo hace más flexible, aunque menos uniforme para algunas aplicaciones.
Líneas de comunicación.
• SCK (Serial Clock): Línea de reloj generada por el maestro para sincronizar la transmisión de datos.
• CS(Chip Select): Línea utilizada por el maestro para seleccionar al esclavo con el que desea comunicarse.
• MOSI (Master Out Slave In): Línea de datos del maestro hacia el esclavo.
• MISO (Master In Slave Out): Línea de datos del esclavo hacia el maestro.
Procedimiento de Comunicación:
• El maestro selecciona un esclavo específico bajando su línea CS correspondiente.
• Genera pulsos de reloj en la línea SCK para sincronizar la transmisión de datos.
• Los datos se envían a través de MOSI desde el maestro al esclavo, mientras que el esclavo puede enviar datos simultáneamente al maestro a través de MISO.
• Una vez completada la transferencia, el maestro libera al esclavo subiendo la línea CS, permitiendo la comunicación con otros dispositivos.
Característica: SPI 
● Modo de Comunicación: Serial síncrono
● Modelo de Comunicación: Maestro-Múltiples Esclavos (selección individual)
● Líneas de Comunicación: 4 líneas (SCK, CS, MOSI, MISO)
● Velocidad Máxima: Hasta 50 MHz
● Control de Esclavo: Línea de selección de chip (CS)
● Número de Dispositivos: Múltiples esclavos con líneas de CS
● Protocolo: Más simple (no requiere ACK)
● Consumo de Pines: Mayor (mínimo 4 pines)
● Idoneidad: Aplicaciones de alta velocidad y transferencia rápida de datos

BLUETOOTH (HC-05)
El módulo Bluetooth HC-05 es un dispositivo ampliamente utilizado en sistemas embebidos para establecer comunicación inalámbrica mediante el estándar Bluetooth. Opera en la banda de 2.4 GHz y soporta modos maestro y esclavo, lo que lo hace adecuado para aplicaciones donde un dispositivo central coordina la interacción con varios periféricos. Entre sus caracter´ısticas más destacadas se incluyen un alcance de hasta 100 metros, baja latencia en
la transmisión de datos (hasta 2.1 Mbps) y bajo consumo energético, lo que lo hace ideal para sistemas portátiles. La configuración del HC-05 se realiza a través de comandos AT enviados por una interfaz UART, permitiendo ajustes como el cambio de nombre, velocidad de transmisión y rol (maestro/esclavo). Para garantizar una comunicación estable, se recomienda trabajar con una velocidad de 38400 baudios en modo AT. En aplicaciones prácticas, este módulo se integra con microcontroladores como el Arduino, permitiendo la transmisión y recepción de datos en tiempo real. Además, soporta múltiples conexiones en modo maestro, lo que lo diferencia de módulos similares como el HC-06. En este proyecto, el HC-05 se utiliza para establecer una comunicación inalámbrica entre los microcontroladores maestro y esclavo, permitiendo la sincronización de las órdenes en los sistemas de control, como la activación de pistones y relés.



SENSOR(DHT-11)
Es un dispositivo ampliamente utilizado en la medición de variables ambientales como temperatura y humedad debido a su simplicidad, bajo costo y capacidad para integrarse en proyectos electrónicos. Este sensor opera con un protocolo de comunicación de un solo hilo (1-Wire), que permite la transmisión de datos de manera eficiente entre el sensor y el microcontrolador, utilizando un solo cable para comunicación bidireccional. Este protocolo se caracteriza por su diseño maestro-esclavo, donde el microcontrolador actúa como el maestro que inicia las comunicaciones y el sensor como esclavo que responde con los datos requeridos. El DHT11 utiliza un termistor de coeficiente de temperatura negativa (NTC) para medir la temperatura, aprovechando el principio de que la resistencia del material semiconductor disminuye con el aumento de la temperatura. Por otro lado, para medir la humedad, incorpora un sensor  capacitivo compuesto por dos electrodos y un material dieléctrico en medio, cuya capacitancia varía según el nivel de humedad presente en el ambiente. El proceso de comunicación del sensor incluye la transmisión de datos que combinan información sobre temperatura, humedad y un mecanismo de verificación (checksum) para garantizar la integridad de los datos recibidos.

INTRODUCCION A C
Lenguaje de tipo de datos estáticos , debidamente tipado , estructuras típicas de alto nivel, dispone de construcciones del lenguaje que permiten un control a bajo nivel, lo que lo convierte en un lenguaje de nivel medio. Los compiladores ofrecen extensiones al lenguaje que posibilitan mezclar código en ensamblador con código C o acceder directamente a la memoria o dispositivos periféricos. similitudes c computador y atmega: sintaxis, declaración de variables, estructuras de control(if ,for, while), funciones , etc. y funciones estándar, se pueden usar muchas de las funciones estándar de c, como op matemáticas, manipulación de bits y control de flujo. diferencias : entorno, librerías, control directo en hardware , recursos limitados, entorno de desarrollo, interrupciones, manejo de tiempo real.

PWM
Consiste en generar un tren de pulsos , siempre del mismo periodo , pero en el que el tiempo en que la seniat es positiva, es un porcentaje del periodo. Duty cycle = ton/toff. una forma de generar un PWM es comprar dos señales de entrada. donde dependiendo de la configuración será diferente en la salida en el mismo periodo. USOS. control de velocidad, posicion servo, intensidad luminica, sonido rustico.Se puede generar de 3 manera, por medio de delay, encender y apagar bit de salida, (forzado), otro, usando interrupciones por desbordamiento, otro por un timmer y la salida por el cual queremos el pwm de forma automática.

PWM forzado.
Es una técnica utilizada para simular diferentes niveles de potencia entregada a un dispositivo, como un LED o un motor, sin cambiar el voltaje de la señal de control. A diferencia de un PWM "natural", que suele estar gestionado por hardware específico del microcontrolador, el PWM forzado se implementa por software, "forzando" manualmente el cambio de estados dentro del ciclo, lo cual es menos eficiente en términos de procesamiento pero permite controlar la potencia incluso en sistemas sin soporte de PWM en hardware.

PWM fast.
Genera una señal de alta frecuencia. El temporizador cuenta desde 0 hasta un valor máximo (MAXVAL) y luego reinicia el conteo. Durante este proceso, cuando el temporizador alcanza el valor de un registro de comparación (OCRnx), ocurre una transición en la salida. Modo No Invertido: La salida se activa (pasa a alto) al empezar el ciclo y se desacelera cuando ocurre la coincidencia con OCRnx. Modo Invertido: La salida se comporta al revés; se activa en la coincidencia y se desacata al inicio del ciclo. El ancho del pulso (ciclo de trabajo) depende del valor configurado en el registro OCRnx. 

Registros clave para PWM:
• OCRnA: Define el duty cycle y los pines de salida.
• ICRn: Establece el valor máximo, que determina la frecuencia de la señal PWM.• TCCRnA y TCCRnB: Configuran la forma de trabajo, la salida y el prescaler.
top = fosc/prescaler*fpwm - 1 , ICRn

ADC
Convierte una amplitud de tensión o corriente en la entrada en un código binario que representa su aproximación. Primero se toma un muestreo de la señal. La cuantificación mide las muestras y les asigna valores decimales. Los valores de las muestras de voltaje se representan en binario. La frecuencia de muestreo debe ser al menos el doble de la frecuencia máxima de la señal a capturar para evitar que se distorsione la señal digital debido a una tasa de muestreo insuficiente.

INICIALIZACIÓN(ADC)
Se establece Vcc del microcontrolador como referencia de voltaje (bit REFS0), convirtiendo los valores analógicos en proporción a este voltaje. Se configura la lectura justificada a la derecha (bit ADLAR). Esto determina cómo se almacena el valor de la conversión en los registros de datos. Se ajusta un prescaler de 64 (bits ADPS2 y ADPS1), que divide la frecuencia del reloj del sistema para adecuarla a la velocidad máxima de operación del ADC. Finalmente, se activa el ADC mediante el bit ADEN.

LECTURA(ADC)
Se elige uno de los 8 canales disponibles (ADC0-ADC7) ajustando los bits correspondientes en el registro ADMUX. Al configurar el bit ADSC, el ADC empieza a convertir el valor analógico en un valor digital. Se monitorea el bit ADSC para saber cuándo termina la conversión. Mientras este bit está en 1, la conversión sigue en proceso; cuando cambia a 0, la conversión ha finalizado. Finalmente, se lee el resultado de la conversión en el registro ADC. Este valor, que estará entre 0 y 1023.

TEMPORIZADORES 
El atmega tiene 3 contadores, el timer 0 y 2 son contadores de 8 bits(255) y el times 1 es de 16(65.536). Se puede generar subrutinas de esperas(delay),pwm para control de leds o motores.
TCNT: almacena el conteo del timer contador, este contador se incrementa 
TIFR: registro que almacena las banderas de estado
TCCRX: Registro de configuración del times 

CONF.INTERRUPCIONES
Habilitar interrupciones globales con sei() en C. Configurar el periférico (temporizador, ADC, etc.) para la interrupción deseada. Activar la interrupción local en el registro correspondiente. Definir la ISR para manejar la interrupción.

SLEEP MODE
Permite reducir el consumo de energía en el microcontrolador. En este modo, la mayoría de los periféricos se apagan, pero algunos, como temporizadores o ciertos pines, pueden mantenerse activos para despertar el sistema. El microcontrolador se despierta por interrupciones, como una señal de temporizador. Existen varios modos de Sleep (Idle, Power-down, Power-save, etc.), cada uno con diferentes niveles de ahorro de energía. iprom = (i1*t1)+(i2*t2)/ (t1+t2)

WATCHDOG TIMER El WDT
Es un temporizador que resetea el microcontrolador si este queda bloqueado, por ejemplo,
en un bucle infinito. El WDT puede configurarse para tiempos de espera de hasta 8
segundos. Si el microcontrolador no resetea el temporizador antes de que desborde, se
genera un reinicio

EEPROM
Se divide en posiciones de 1 byte (8 bits, es decir número entre 0-255) cada una. Su capacidad varía según el microcontrolador, y algunos no la tienen. Su vida útil es de alrededor de 100,000 ciclos de escritura. Para almacenar un dato se debe indicar la posición y luego el valor.

ESCRITURA(EEPROM)

LECTURA(EEPROM)
PARCIAL 1 TEÓRICO
GIT Y GITHUB
Git es un sistema de gestión de versiones distribuido, también es open source y se puede integrar
con diferentes repositorios.  Por otro lado, puede ser usado para controlar versiones de código, documentos o archivos en general.
Proceso: en GIT BASH,  Navegar al directorio del repositorio con el comando CD “Nombre_Carpeta” , generar una rama nueva llamada PRUEBA con:,  Git checkout –b PRUEBA, Modificar el archivo README.md con VIM usando el comando: Vi README , Añadir los cambios a la rama con el comando: git add README.md Generar el commit con: Git commit –m “Primer Cambio”, Actualizar el repositorio con: Git push origin main y por último Verificar el cambio en github.

STACK POINTER
Se entiende por Stack Ponter , un registro especial que apunta a la última dirección de la pila de memoria utilizada, el modo que funciona es el lifo, el último en entrar y el primero en salir.  Este almacena la dirección de retorno o variables al ocurrir una llamada en la subrutina se decrementa cuando ocurre un almacenamiento push y se incrementa cuando hay una recuperación pop, gestiona los saltos producidos cuando ocurre una interrupción, se almacena el contexto actual del microprocesador para poder retomarla después de procesada la interrupción.

STS,ST, STD:







PARCIAL 2 TEÓRICO
USART(rx,tx,clk)
Comunicación serial síncrona, ambos dispositivos comparten una línea de reloj (CLK), permite que la transmisión de datos esté sincronizada. Cada dispositivo tiene una línea TX RX, lo que permite el envío y recepción simultánea de datos. 
A diferencia de UART, donde no se comparte el reloj, aquí el dispositivo maestro envía pulsos de reloj que marcan cuándo deben leerse o escribirse los bits. El formato de datos se compone de una secuencia de bits que se transmiten sincronizados con los flancos del reloj, típicamente empezando por el bit menos significativo (LSB) o más significativo (MSB), según la configuración.

FUNCIONAMIENTO ULTRASÓNICO HC-SR04
Se usa para medir distancias. El transmisor envía una señal de 40 kHz y el receptor mide el tiempo que tarda en regresar el eco, calculando así la distancia al objeto. Tiene un rango de 2 cm a 400 cm. El pin Trig se activa en alto por 10 µs para iniciar un pulso ultrasónico. El pin Echo se pone en alto mientras se envía y recibe el eco. Midiendo el tiempo que permanece alto, se calcula la distancia al objeto. distancia = velocidad x tiempo, como el pulso va y viene se divide entre 2 .

VENTAJAS UN PIN TECLADO MATRICIAL
Al utilizar un pin solo del arduino se puede ahorrar pines del mismo, pero es más complejo a nivel de código. Para el caso de utilizar 4 pines para las columnas y 4 pines para las filas, hace que se ocupen más pines y aparte que esto, para que funcione se debe implementar un ciclo for para filas y uno para columnas, lo que perjudica en la utilización de pines pwm si se quisiese usar para otra cosa. 

PASO A PASO(unipolar de bipolar)

PASOS CONVERTIR(analogica/digital)ADC

GRÁFICO DE FUNCIONAMIENTO
Esto es una forma de comunicación SPI de forma directa ya que tiene un CS (selector), del maestro para cada esclavo lo que hace que la comunicación sea más rápida, de otro modo si tuviese un selector solo del maestro para todos los esclavos esto perjudica en la velocidad de transmisión de datos.

PROTOCOLO 1-WIRE, (1,0)
Interfaz de comunicación serial de un solo hilo, bidireccional y de baja velocidad, funciona en modo maestro-esclavo, permitiendo un maestro y hasta 100 esclavos, aunque aumenta el tiempo de comunicación con más dispositivos. Para la escritura de Datos, el maestro envía un 1 o 0 lógico ajustando la duración de la señal baja (1-15 µs para 1, 60-120 us para 0). Para la lectura de datos el maestro envía un 1 lógico, si el esclavo responde con un 1, la señal se mantiene en alto. Para un 0 lógico, el esclavo mantiene la señal en bajo.

PERIFÉRICO WDT
Es un temporizador que resetea el microcontrolador si este queda bloqueado, por ejemplo, en un bucle infinito. Se puede configurar para tiempos de espera de hasta 8 segundos. Si el microcontrolador no resetea el temporizador antes de que desborde, se genera un reinicio.



